# -*- coding: utf-8 -*-
"""ML_A4_spam_email.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WWSj5scvVADGmMQJ9vX2SDhTCIw9zBEK

# **Machine Learning**

# **Assignment 4**

# Classification of Email spam

Name   : Jaanus Sri K G

Reg no : 3122215001037

Importing Libraries
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import MinMaxScaler
from sklearn.model_selection import train_test_split
from sklearn.svm import SVC
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, confusion_matrix

"""Step 1: Load the Email Spam dataset

"""

data = pd.read_csv('/content/spam_email/spambase_csv.csv')

"""Step 2: Preprocessing (if needed)

No preprocessing required for SVM with text data
"""

from sklearn.preprocessing import MinMaxScaler

scaler = MinMaxScaler(copy=True, feature_range=(0, 1))
X = scaler.fit_transform(data.iloc[:,:-1])
y = data.iloc[:,-1]

"""Step 3: Exploratory Data Analysis

"""

# Checking correlations
sns.heatmap(data.corr())
plt.title('Correlation Heatmap')
plt.show()

# Pie chart of class distribution
plt.figure(figsize=(8, 8))
data['class'].value_counts().plot(kind='pie', autopct='%1.0f%%')
plt.title('Class Distribution')
plt.show()

"""Feature Engineering Techniques:
Feature engineering involves creating new features or modifying existing ones to improve model performance. For this dataset, you can explore techniques such as:
    Selecting relevant features
    Transforming features (e.g., log transformation)
    Creating interaction terms

Step 4: Split the dataset into training and testing sets
"""

X = data.iloc[:, :-1]
y = data['class']
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.33, random_state=44, shuffle=True)

"""Step 5: Build SVM models with different kernel functions

"""

kernels = ['linear', 'rbf', 'poly', 'sigmoid']
results = {}
for kernel in kernels:
    print("Kernel:", kernel)
    model = SVC(kernel=kernel)
    model.fit(X_train, y_train)

    # Step 6: Evaluate the model
    train_accuracy = model.score(X_train, y_train)
    test_accuracy = model.score(X_test, y_test)
    print("Training Accuracy: ", train_accuracy)
    print("Test Accuracy    : ", test_accuracy)

    # Step 7: Get additional metrics if needed
    y_pred = model.predict(X_test)
    #print("Accuracy         : ", accuracy_score(y_test, y_pred)
    print("Precision        : ", precision_score(y_test, y_pred))
    print("Recall           : ", recall_score(y_test, y_pred))
    print("F1 Score         : ", f1_score(y_test, y_pred))
    print("Confusion Matrix :\n", confusion_matrix(y_test, y_pred))

    # Storing results for analysis
    results[kernel] = {'train_accuracy': train_accuracy, 'test_accuracy': test_accuracy}
    print("\n")

"""Step 8: Compare the results of different kernel functions

"""

#Analysis

print("Analysis of Results:")
for kernel, result in results.items():
    print("Kernel:", kernel)
    print("Training Accuracy:", result['train_accuracy'])
    print("Test Accuracy:", result['test_accuracy'])
    print("\n")

# Comparing test accuracies

test_accuracies = [result['test_accuracy'] for result in results.values()]
best_kernel = kernels[np.argmax(test_accuracies)]
print("Best Kernel (based on test accuracy):", best_kernel)

# Visualization of test accuracies

plt.figure(figsize=(10, 6))
plt.bar(kernels, test_accuracies)
plt.xlabel('Kernel Function')
plt.ylabel('Test Accuracy')
plt.title('Test Accuracies for Different Kernel Functions')
plt.show()

"""#This implementation provides a comprehensive analysis of SVM models with different kernel functions for email spam classification and helps in understanding which kernel function performs best for this task.

**Comparison of Results:**

* We compared the training and test accuracies as well as confusion matrices for different kernel functions.

* We observed that the linear kernel achieved the highest test accuracy in this scenario.

**Best Kernel:**

* We identified the best kernel based on test accuracy.

* In this case, the linear kernel performed the best.
"""